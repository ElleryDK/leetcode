## 2829. k-avoiding 数组的最小总和
> 对于一个由 不同 正整数组成的数组，如果其中不存在任何求和等于 k 的不同元素对，则称其为 k-avoiding 数组。  
返回长度为 n 的 k-avoiding 数组的可能的最小总和。
```java
public int minimumSum(int n, int k) {//贪心算法
    int origin =1;
    ArrayList<Integer> res = new ArrayList<>();
    int sum = 0;
    HashMap<Integer,Integer> mp = new HashMap<>();
    for(int i =1;i<=k;i++){//最小的优先放入，排除较大的不满足条件的数
        if(!mp.containsKey(k-origin)){
             mp.put(origin,1);
            res.add(origin);
        }
        origin++;
    }
    int tmp = n>res.size()?res.size():n;
    for(int i =0 ;i <tmp;i++){//筛选出来的数数量不够补足数量
        sum+= res.get(i);
    }
    while(res.size()<n){
        k++;
        sum+=k;
        n--;
    }
    return sum;
}
```

## 153.二叉树中和为目标值的路径
```java
class Solution {//递归
    public List<List<Integer>> res = new ArrayList<>();
    public LinkedList<Integer> path = new LinkedList<>();
    public List<List<Integer>> pathTarget(TreeNode root, int target) {
        ArrayList<Integer> path = new ArrayList<>();
        dfs(root,target);
        return res;
    }
    private void dfs(TreeNode node,int target){
        if(node==null)
            return ;
        path.add(node.val);
        target -= node.val;
        if( target==0&&node.left==null&&node.right==null)
            res.add(new LinkedList(path));
        dfs(node.left,target);
        dfs(node.right,target);
        path.removeLast();
    }
}
```